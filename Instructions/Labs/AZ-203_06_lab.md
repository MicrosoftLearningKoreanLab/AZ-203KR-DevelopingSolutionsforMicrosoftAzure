---
lab:
    title: '랩: Azure에서 서비스를 사용하여 다중 계층 솔루션 만들기'
    module: '모듈 6: Azure 및 타사 서비스'에 연결하고 사용'
---

# 랩: Azure에서 서비스를 사용하여 다중 계층 솔루션 만들기
# 학생 랩 매뉴얼

## 랩 시나리오

회사에서 솔루션의 다양한 사용 사례에서 Microsoft Azure Search 를 성공적으로 채택하고 사용했습니다. 최신 솔루션에서 회사에서 Azure Storage 테이블에 데이터를 저장하고 Azure 검색을 사용하여 해당 테이블을 인덱싱 해야 합니다. 이를 위해 최소한의 코드로 API 를 빌드합니다. 이 솔루션에는 두 가지 주요 요구 사항이 있습니다. 첫째, REST 쿼리를 실행하는 개발자는 Azure Search가 백그라운드에서 사용되고 있다는 세부 사항을 인식하지 않아야 합니다. 둘째, 개발자는 간단한 REST 쿼리를 사용하여 테이블에 새 레코드를 추가할 수 있어야 합니다. Azure Search, Azure API Management 및 Azure Logic Apps를 사용하여 이러한 모든 요구 사항을 충족하는 최소 코드 솔루션을 빌드하기로 결정했습니다.

## 목표

이 랩을 완료하면 다음을 수행할 수 있습니다.

-   Azure Search 계정을 만듭니다.

-   Azure Search 인덱스를 수동으로 만듭니다.

-   데이터 원본에서 데이터를 자동으로 구문 분석하는 인덱서를 만듭니다.

-   API Management 계정을 만듭니다.

-   헤더 대체 및 페이로드 조작을 통해 다른 Azure 서비스에 대한 프록시로 API를 구성합니다.

-   Logic Apps 리소스를 만듭니다.

-   HTTP 요청에 의해 트리거되는 워크플로를 구성합니다.

## 랩 설정

-   **예상 시간**: 105 분

## 지침

### 시작하기 전에

#### 랩 가상 머신에 로그인

다음 자격 증명을 사용하여 **Windows 10** 가상 머신에 로그인해야 합니다.

-   **사용자 이름**: Admin

-   **암호**: Pa55w.rd

#### 설치된 응용 프로그램 검토

**Windows 10** 바탕 화면 하단에 있는 작업 표시줄을 살펴봅니다. 작업 표시줄에는 이 랩에서 사용할 응용 프로그램에 대한 아이콘이 포함되어 있습니다.
    
-   Microsoft Edge

-   파일 탐색기

-   마이크로소프트 Azure 스토리지 탐색기

#### 랩 파일 다운로드

1.  작업 표시줄에서 **Windows PowerShell** 아이콘을 선택합니다.

1.  PowerShell 명령 프롬프트에서 현재 작업 디렉터리를 **Allfiles(F):\\** 경로로 변경합니다.

```
    cd F:
```

1.  명령 프롬프트 내에서 다음 명령을 입력하고 Enter 키를 눌러 GitHub에서 호스트되는 **microsoftlearning/AZ-203-DevelopingSolutionsforMicrosoftAzure** 프로젝트를 **Allfiles (F):\\** 드라이브로 복제합니다.

```
    git clone --depth 1 --no-checkout https://github.com/microsoftlearning/AZ-203-DevelopingSolutionsForMicrosoftAzure.
```

1.  명령 프롬프트 내에서 다음 명령을 입력하고 **Enter** 키를 눌러 **AZ-203T06** 랩을 완료하는 데 필요한 랩 파일을 체크 아웃합니다.

```
    git checkout master -- Allfiles/*
```

1.  현재 실행 중인 **Windows PowerShell** 명령 프롬프트 응용 프로그램을 닫습니다.

### 연습 1: 포털에서 Azure 검색 서비스 만들기

#### 작업 1: Azure Portal 열기

1.  [**Azure Portal**](https://portal.azure.com)(portal.azure.com)에 로그인합니다.

1.  Azure 포털에 처음 로그인하는 경우 포털 둘러보기를 제공하는 대화 박스가 표시됩니다. 투어를 건너뛰려면 **시작하기**를 선택합니다.

#### 작업 2: API Management 리소스 만들기

> Azure Portal에서 다음과 같은 세부 정보를 사용하여 새 **API Management 계정**을 만듭니다.

  - **기존 리소스 그룹**: MultiTierService

  - **이름**: prodapi\[소문자로 된 사용자 이름\]

  - **위치**: 미국 동부

  - **조직 이름**: Contoso

  - **가격 계층**: 개발자(SLA 없음)

> **참고**: 이 랩을 진행하기 전에 Azure 에서 API 관리 계정 만들기가 완료될 때까지 기다립니다. 계정이 생성되면 알림을 받게 됩니다. API 관리 서비스를 만드를 위하여 일반적으로 20~30 분이 걸립니다.

#### 작업 3: Azure 검색 계정 만들기

1.  다음 세부 정보를 사용하여 새 **Azure Search** 인스턴스를 만듭니다.
    
      - **URL**: prodsearch\[소문자로 된 사용자 이름\]
    
      - **새 리소스 그룹**: 멀티티어 서비스
    
      - **위치**: 미국 동부
    
      - **가격 계층**: 기본

        > **참고**: 랩을 진행하기 전에 Azure가 Azure Search 계정 만들기를 완료할 때까지 기다립니다. Azure Search 계정이 만들어지면 알림을 받게 됩니다.

1.  새로 만든 **Azure 검색** 인스턴스의 **키** 블레이드에 액세스합니다.

1.  **검색 키** 중 하나를 기록합니다. 이 값은 랩의 나중에 사용합니다.

#### 작업 4: 인덱스 만들기

1.  이 랩의 앞에서 만든 **prodsearch\*** 검색 서비스에 액세스합니다.

1.  **검색 서비스** 블레이드에서 **인덱스 추가**를 선택합니다.

1.  다음 세부 정보에 따라서 새 인덱스를 만들겁니다:
    
      - **인덱스 이름**: 소매
    
      - **키**: id

1.  아래 표를 사용하여 인덱스 필드를 구성합니다.

| **필드**        | **입력**   | **조회 가능** | **필터링** | **정렬** | **페이스 테이블** | **검색** | **분석**          |
| ---------------- | ---------- | --------------- | -------------- | ------------ | ------------- | -------------- | --------------------- |
| **id**           | 에드름.스트링 | **✓**           |                | **✓**        |               |                |                       |
| **이름**         | 에드름.스트링 | **✓**           |                | **✓**        |               | **✓**          | **표준 - 루센** |
| **가격**        | 에드름 더블 | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |
| **수량**     | Edm.Int32  | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |
| **제조업체** | 에드름.스트링 | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |

#### 검토

이 연습에서는 새 Azure Search 계정을 만들고 계정 내에 인덱스를 작성했습니다.

### 연습 2: Azure Search에서 Azure Storage 테이블 인덱싱

#### 작업 1: Azure 저장소 계정 만들기

1.  Azure 포털에서 다음과 같은 세부 정보를 사용하여 새 **저장소 계정**을 만듭니다.
    
      - **기존 리소스 그룹**: MultiTierService
    
      - **이름**: prodstorage\[소문자로 된 사용자 이름\]
    
      - **위치**: (미국) 미국 동부
    
      - **성능**: 표준
    
      - **계정 종류**: 스토리지 V2(범용 v2)
    
      - **복제**: 읽기 액세스 지리적 중복 스토리지(RA-GRS)
    
      - **액세스 계층**: 핫

        > **참고**: 랩을 진행하기 전에 Azure에서 스토리지 계정 만들기가 완료될 때까지 기다립니다. 계정이 생성되면 알림을 받게 됩니다.

1.  새로 만든 **스토리지 계정** 인스턴스의 **액세스 키** 블레이드에 액세스합니다.

1.  **연결 문자열** 필드의 값을 기록합니다. 이 랩에서 나중에 이 값을 사용합니다.

#### 작업 2: Azure 저장소에 테이블 엔터티 업로드

1.  이전에 랩에서 만든 ** prodstorage\*** 저장소 계정에 액세스합니다.

1.  **테이블 서비스** 섹션에서 **테이블** 링크를 선택합니다.

1.  다음 설정을 사용하여 **새** 테이블을 만듭니다.
    
      - **이름**: 제품

1.  블레이드의 **개요** 섹션에서 **탐색기에서 열기**를 선택하여 **Azure 저장소 탐색기**를 사용하여 저장소 계정을 엽니다.

1.  이전에 랩에서 만든 **prodstorage\*** 저장소 계정에 나타나는 **Azure 저장소 탐색기** 응용 프로그램에서 **제품** 테이블을 찾아 엽니다.

1.  **제품 테이블** 탭에서 **가져오기**를 선택하고 랩 머신의 **Allfiles (F):\\Allfiles\\Labs\\06\\Starter** 폴더에 있는 **products.csv** 파일을 가져옵니다.

#### 작업 3: Azure 검색 인덱서 만들기

1.  이전에 랩에서 만든 **prodsearch\*** 검색 서비스에 액세스합니다.

1.  **검색 서비스** 블레이드에서 **수입 데이터**를 선택합니다.

1.  **수입 데이터**가 블레이드에서 다음과 같은 세부 정보가 있는 새 인덱서를 만듭니다.
    
    - **데이터 원본**: Azure 테이블 저장소

    - **데이터 원본 이름**: 테이블 데이터 원본

    - **연결 문자열**: 이전에 랩에서 만든 **prodstorage\*** 저장소 계정을 선택합니다.\>*

    - **표명**: 제품

    - **인덱스 이름**: 제품

    - **키**: 로우키

    - 아래 표를 사용하여 인덱스 필드를 구성합니다.

        | **필드**    | **입력**   | **조회 가능** | **필터링** | **정렬** | **페이스 테이블** | **검색** | **분석**          |
        | ------------ | ---------- | --------------- | -------------- | ------------ | ------------- | -------------- | --------------------- |
        | **키**      | 에드름.스트링 | **✓**           |                | **✓**        |               |                |                       |
        | **이름**     | 에드름.스트링 | **✓**           |                | **✓**        |               | **✓**          | **표준 - 루센** |
        | **가격**    | 에드름 더블 | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |
        | **수량** | Edm.Int32  | **✓**           | **✓**          | **✓**        | **✓**         |                |                       |

    - **인덱서 이름**: tableindexer

    - **일정**: 사용자 지정

    - **간격**: 5
    
    - **시작 시간**: *오늘 날짜의 자정 UTC*

        > **참고**: **제출** 단추를 표시하려면 **삭제 추적** 필드와 **한 번/사용자 지정** 옵션을 선택한 다음 선택 취소해야 할 수 있습니다. 이 동작은 포털 버그 때문입니다.

1.  이 랩에서 만든 **tableindexer** 인덱서를 수동으로 **실행**합니다.

1.  **tableindexer** 인덱서와 최근 인덱서 실행의 메타데이터를 확인합니다. 메타데이터에는 문서 수 및 마지막 인덱싱 작업의 상태와 같은 정보가 포함됩니다. 마지막 인덱싱 작업이 성공하여 여러 문서가 인덱스에 추가되었음을 관찰할 수 있습니다.

#### 작업 4: 인덱싱된 테이블 데이터의 유효성 검사

1.  이전에 랩에서 **검색 탐색기**를 **prodsearch\*** 검색 서비스를 엽니다.

1.  모든 필드를 기본값(빈) 값으로 설정하고 **Enter** 를 선택하여 빈 쿼리를 실행합니다. 이 쿼리의 결과는 인덱스의 모든 문서에 대한 결과 페이지를 반환합니다.

1.  다음 쿼리를 실행하고 결과를 관찰합니다.


```
    search=seat
```

1.  다음 쿼리를 실행하고 결과를 관찰합니다.


```
    $filter=price lt 100
```

1.  다음 쿼리를 실행하고 결과를 관찰합니다.


```
    facet=quantity,interval:25
```

1.  다음 쿼리를 실행하고 결과를 관찰합니다.


```
    $filter=quantity gt 25&facet=price,values:100|1000|10000
```

#### 작업 5: Azure 검색 기본 URL 검색

1.  이전에 랩에서 만든 **prodsearch\*** 검색 서비스에 액세스합니다.

1.  **검색 서비스** 블레이드에서 **URL** 필드의 값을 복사합니다. 이 값은 랩의 나중에 사용합니다.

#### 검토

이 연습에서는 Azure Storage 계정을 만들고 Azure Search 를 사용하여 계정 내에서 저장소 테이블을 인덱싱했습니다. 테이블을 인덱싱한 후 Storage 테이블의 엔터티 복사본에 대해 검색 쿼리를 발급할 수 있었습니다.

### 연습 3: Azure API 관리를 사용하여 API 프록시 계층 빌드

#### 작업 1: 새 API 정의

1.  이전에 랩에서 만든 **prodapi\*** API 관리 계정에 액세스합니다.

1.  새 계정의 **API** 목록을 봅니다.

> **참고**: 모든 새 계정은 간단한 **에코API**로 시작합니다.

1.  다음 세부 정보에 따라서 블랙 **빈칸 API**를 만들겁니다
    
    - **표시 이름**: API 검색

    - **이름**: 검색 API

    - **웹 서비스 URL**: 이전에 랩에서 복사한 **검색 서비스 URL**을 입력합니다. **웹 서비스 URL** 필드의 값을 다음 상대 URL 로 보겠습니다.

```
        /indexes/products/docs
```

        > **참고**: 예를 들어 웹 서비스 URL이 https://prodsearchstudent.search.windows.net인 경우 새 URL은 https://prodsearchstudent.search.windows.net/indexes/products/docs가 됩니다.

    - **API URL 접미사**: 검색

    - **제품**: **스타터** 와 **무제한** 옵션을 모두 선택합니다.

1.  다음과 같은 세부 정보를 사용하여, 최근에 만든 API에 새 **작업**을 추가합니다.
    
      - **표시 이름**: 자동 전송 라이브러리에
    
      - **이름**: 목록 - 모든 문서
    
      - **URL**: GET /

1.  다음 세부 정보를 사용하여 **모든 작업**에 새 **헤더 설정** 인바운드 정책을 추가합니다.
    
      - **이름**: API 키
    
      - **값**: 이전에 랩에서 기록한 검색 서비스 키값을 입력합니다.

1.  다음 세부 정보를 사용하여 모든 작업에 새 **쿼리 매개 변수** 인바운드 정책을 **추가합니다**.
    
      - **이름**: api 버전
    
      - **값**: 2017-11-11
    
      - **동작**: 재정의

1.  다음 세부 정보를 사용하여 **모든 문서 목록** 작업에 범위가 **지정된 새쿼리매개 변수** 인바운드 정책을 추가합니다.
    
      - **이름**: 검색
    
      - **값**: *\**
    
      - **동작**: 재정의

1.  API 요청결과를 관찰하는 **검색 API**에서 **모든 문서 목록** 작업을 테스트합니다.

    > **참고**: 응답에 많은 양의 Azure Search 메타데이터가 있는 방법을 관찰합니다. API 사용자가 뒤에서 발생하는 구현 세부 정보를 관찰하지 않도록 할 수 있습니다. 다음 작업에서는 이 데이터의 대부분을 난독 처리합니다.

#### 작업 2: API 응답 조작

1.  다음 세부 정보와 함께 **모든 작업**에 새 **지정된 헤더** 아웃바운드 정책 추가:
    
    1.  **이름**: 기본 설정 적용
    
    1.  **작업**: 삭제

1.  다음 세부 정보를 사용하여 **모든 작업**에 새 **헤더 설정** 아웃바운드 정책을 추가합니다.
    
    1.  **이름**: odata-version
    
    1.  **작업**: 삭제

1.  다음 세부 정보를 사용하여 **모든 작업**에 새 **헤더 설정** 아웃바운드 정책을 추가합니다.
    
    1.  **이름**: powered-by
    
    1.  **값**: Contoso
    
    1.  **동작**: 재정의

1.  XML 콘텐츠의 다음 블록을 먼저 찾아 **모든 문서 목록** 작업에 범위가 지정된 새 사용자 지정 아웃바운드 정책을 추가합니다.


```
    <outbound>
        <base />
    </outbound>
```

그런 다음 XML의 해당 블록을 다음 XML로 바꿉니다.
    
```
    <outbound>
        <base />
        <set-body>
        @{ 
            var response = context.Response.Body.As<JObject>();
            return response.Property("value").Value.ToString();
        }
        </set-body>
    </outbound>
```

1.  **검색 API**에서 **모든 문서 목록** 작업을 테스트하여 API 요청 결과를 확인합니다.

    > **참고**: 지정한 기본 **설정 적용** 및 **odata-version** 헤더가 삭제되고 새 **전원이 지정된 헤더**로 대체된 것을 관찰할 수 있습니다. 또한 응답에는 OData 응답에 대한 컨텍스트 데이터가 포함되지 않고 대신 평판이 난 JSON 배열을 응답 본문으로 포함합니다.

#### 검토

이 연습에서는 Azure Search 계정과 검색 쿼리를 만들려는 개발자 간에 프록시 계층을 구축했습니다.

### 연습 4: Azure Logic Apps를 사용하여 새 테이블 엔터티 만들기

#### 작업 1: Logic Apps 리소스 만들기

1. Azure Portal에서 다음과 같은 세부 정보를 사용하여 새 **논리 앱**을 만듭니다.
    
    - **기존 리소스 그룹**: MultiTierService

    - **이름**: prodworkflow\[소문자로 된 사용자 이름\]

    - **위치**: 미국 동부

    - **로그 분석**: 제안

        > **참고**: 랩을 진행하기 전에 Azure가 Logic Apps 리소스 만들기를 완료할 때까지 기다립니다. 리소스가 생성되면 알림을 받게 됩니다.

#### 작업 2: 로직 어플 워크플로우에 대한 트리거 만들기

1.  **로직 어플 디자이너** 블레이드에서 **빈칸 로직 어플** 템플릿을 선택합니다.

1.  **디자이너** 영역에서 다음 샘플 JSON 문서를 사용하여 새 **HTTP 요청을 수신할 때** 트리거를 추가하여 JSON 스키마를 생성합니다.


```
    { 
        "id": "",
        "manufacturer": "",
        "price": 0.00,
        "quantity": 0,
        "name": ""
    }
```

#### 작업 3: Azure 저장소용 커넥터 구축

1. **디자이너** 영역에서 새 "**엔터티 삽입 또는 바꾸기"**작업을 다음과 같은 세부 정보와 함께 추가합니다.

    - **연결 이름**: 테이블 연결

    - **저장소 계정**: 이전에 랩에서 만든 **prodstorage\*** 저장소 계정을 선택합니다.

    - **표**: 제품

    - **파티션 키**: 제조업체(동적 필드 - HTTP 요청이 수신된 경우)

    - **로 키**: ID (동적 필드 - HTTP 요청이 수신된 경우)

    - **엔터티**: 본문(동적 필드 - HTTP 요청이 수신된 경우)

#### 작업 4: HTTP 응답 작업 빌드

1. **디자이너** 영역에서 다음과 같은 세부 정보와 함께 새 **응답 작업**을 추가합니다.
    
    - **상태 코드**: 201
    
    - **본문**: 본문(동적 필드 - 엔티티 삽입 또는 바꾸기)

#### 작업 5: HTTP 트리거 POST URL 검색

1.  **디자인** 영역에서**저장**를 선택합니다.

1.  워크플로를 저장한 후 **HTTP 요청이 수신될 때** 트리거의 **HTTP POST URL** 필드가 이 워크플로 를 시작해야 하는 새URL로 업데이트됩니다. **HTTP POST URL** 필드의 URL 을 복사합니다. 이 URL 은 랩의 나중에 사용합니다.

    > **참고**: SAS 토큰이 있는 URL을 포함하기 때문에 매우 긴 URL입니다. 전체 URL 을 복사해야 합니다.

#### 작업 6: 로직 어플 결과가 인덱싱되어 있는지 확인

1.  새 Azure 클라우드 셸 인스턴스를 엽니다.

1.  **Cloud Shell**이 아직 구성되지 않은 경우 기본 설정을 사용하여 Bash용 셸을 구성합니다.

1.  Cloud Shell 명령 프롬프트 내에서 다음 부분 **CURL** 명령을 입력하여 Logic Apps 인스턴스에 대한 **HTTP POST** 요청을 실행하고 Enter 키를 누릅니다.


```
    curl \
    --header "Content-Type: application/json" \
    --data '{"id":"6","manufacturer":"VEHTOP","price":750,"quantity":6,"name":"car roof rack"}' \
```

1.  그런 다음 이 랩의 앞에서 복사한 논리 앱*의* **HTTP POST URL**을 입력하여 URL 문자가 이스케이프되지 않도록 **따옴표** 내에 URL을 배치합니다. **Enter** 키를 눌러 수식 작성을 완료합니다.

    > **참고**: 예를 들어 URL이 https://prod.eastus.logic.azure.com:443/workflows/test/triggers/invoke?api-version=2016\&sig=3인 경우 “https://prod.eastus.logic.azure.com:443/workflows/test/triggers/manual?invoke?api-version=2016\&sig=3”을 입력합니다. 따옴표를 포함하지 않으면 SAS 토큰이 잘렸으며 요청을 실행해야 한다는 오류 메시지가 표시됩니다. 이 문제는 쿼리 문자열 구분 기호 **&** 따옴표로 묶이지 않은 경우 잘리기 때문에 발생합니다.

1.  이전에 랩에서 만든 **prodsearch\*** 검색 서비스에 액세스합니다.

1.  이 랩에서 방금 만든 **테이블 인덱서** 인덱서를 수동으로 **실행합니다**.

1.  이전에 랩에서 만든 **prodsearch\*** 검색 서비스에 대한 **검색 탐색기**를 엽니다.

1.  빈 쿼리를 실행하고 결과를 관찰합니다.

    > **참고**: 이 시점에서 로직 어플에 의해 삽입된 새 문서를 나타내는 인덱스의 여섯 번째 문서를 확인할 수 있습니다.

1.  이전에 랩에서 만든 **prodapi\*** API 관리 계정에 액세스합니다.

1.  API 요청 결과를 관찰하는 **검색 API**에서 **모든 문서 목록** 작업을 테스트합니다.

    > **참고**: 이제 5개가 아닌 6개의 문서가 있는 것을 볼 수 있습니다.

#### 검토

이 연습에서는 HTTP 요청을 받아 JSON 요청의 JSON 본문을 새 Azure Storage 테이블 엔터티로 유지 하는 로직 어플을 만들었습니다.

### 연습 5: 구독 정리 

#### 작업 1: Cloud Shell 열기

1.  포털 상단에서 **Cloud Shell** 아이콘을 선택하여 새 셸 인스턴스를 엽니다.

1.  포털 하단에서 **Cloud Shell** 명령 프롬프트에서 다음 명령을 입력하고 Enter 를 눌러 구독의 모든 리소스 그룹을 나열합니다.


```
    az group list
```

1.  다음 명령을 입력하고 Enter 키를 눌러 리소스 그룹을 삭제하는 데 사용할 수 있는 명령 목록을 봅니다.


```
    az group delete --help
```

#### 작업 2: 리소스 그룹 삭제

1.  다음 명령을 입력하고 Enter 를 눌러 **MultiTierService** 리소스 그룹을 삭제합니다.


```
    az group delete --name MultiTierService --no-wait --yes
```

1.  포털 하단의 **Cloud Shell** 창을 닫습니다.

#### 작업 3: 활성 애플리케이션 닫기

1.  현재 실행 중인 **Microsoft Edge** 응용 프로그램을 닫습니다.

1.  현재 실행 중인 **Microsoft Azure** 저장소 탐색기 응용 프로그램을 닫습니다.

#### 검토

이 연습에서는 이 랩에 사용된 **리소스 그룹**을 제거하여 구독을 정리했습니다.
